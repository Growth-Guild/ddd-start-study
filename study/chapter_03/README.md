# Chapter 3. 애그리거트

## 3.1 애그리거트
* 상위 수준 개념을 이용해서 전체 모델을 정리하면 전반적인 관계를 이애하는 데 도움이 된다.
* 애그리거트는 관련된 객체를 하나의 군으로 묶어 준다.
* 수많은 객체를 애그리거트로 묶어서 바라보면 상위 수준에서 도메인 모델 간의 관계를 파악할 수 있다.
* 애그리거트는 모델을 이해하는 데 도움을 줄 뿐만 아니라 일관성을 관리하는 기준도 된다.
* 애그리거트는 관련된 모델을 하나로 모았기 때문에 한 애그리거트에 속한 객체는 유사하거나 동일한 라이프 사이클을 갖는다.
* 애그리거트는 경계를 갖는다. 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다.
* 애그리거트는 독립된 객체 군이며, 각 애그리거트는 자기 자신을 관리할 뿐 다른 애그리거트를 관리하지 않는다.

### 애그리거트의 경계를 나누는 기준
* 경계를 설정할 때 기본이 되는 것은 도메인 규칙과 요구사항이다.
* 도메인 규칙에 따라 함께 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높다.
  * 예를 들어 주문할 상품 개수, 배송지 정보, 주문자 정보는 주문 시점에 함께 생성된다.
  * 주문 상품의 개수가 변경되면 도메인 규칙에 따라 총 주문 금액 또한 변경된다.
  * 이렇게 함께 변경되는 빈도가 높은 객체는 한 애그리거트에 속할 가능성이 높다.
* 'A가 B를 갖는다.'로 설계할 수 있는 요구사항이 있다면 A와 B를 한 애그리거트로 묶어서 생각할 수 있지만 반드시 그러한 것은 아니다.
  * 예를 들어 상품과 리뷰에 대한 엔티티가 있다.
  * 상품 엔티티와 리뷰 엔티티는 함께 생성되지 않고, 함께 변경되지도 읺는다.
  * 상품을 변경하는 주체가 상품 담당자라면 리뷰를 생성하고 변경하는 주체는 고객이다.
  * 상품과 리뷰의 변경이 서로에게 영향을 주지 않기 때문에 한 애그리거트에 속하지 않는다.
* 처음 도메인 모델을 만들 때는 큰 애그리거트로 보이는 것들이 많지만, 도메인에 대한 경험이 생기고 도메인 규칙을 제대로 이해할수록 애그리거트의 크기는 줄어든다.

## 3.2 애그리거트 루트
* 애그리거트는 여러 객체로 구성되기 때문에 한 객체만 상태가 정상이면 안 된다. 도메인 규칙을 지키려면 애그리거트에 속한 모든 객체가 정상 상태를 가져야 한다.
* 애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요한데, 이 책임을 지는 것이 애그리거트 루트 엔티티이다.
* 애그리거트 루트는 애그리거트의 일관성이 깨지지 않도록 도메인 기능을 구현해야 한다.
* 애그리거트에 속한 객체를 직접 변경하면 안 된다.
  * 단순히 필드를 변경하는 set 메서드를 public 범위로 만들지 않는다.
  * 밸류 타입은 불변으로 구현한다.
* 밸류 타입의 내부 상태를 변경하려면 애그리거트 루트를 통해서만 가능하도록 구현한다.
  * 애그리거트 루트가 도메인 규칙을 올바르게 구현하면 애그리거트 전체의 일관성이 유지된다.

### 트랜잭션 범위
* 트랜잭션 범위는 작을수록 좋다.
* 동일하게 한 트랜잭션에서는 한 개의 애그리거트만 수정해야 한다.
* 한 트랜잭션에서 한 애그리거트만 수정한다는 것은 애그리거트에서 다른 애그리거트를 변경하지 않는다는 것을 의미한다.
* 애그리거트는 최대한 서로 독립적이어야 한다.
* 도메인 이벤트를 사용하면 한 트랜잭션에서 한 개의 애그리거트를 수정하면서도 동기나 비동기로 다른 애그리거트의 상태를 변경하는 코드를 작성할 수 있다.

## 3.3 리포지토리와 애그리거트
* 애그리거트는 개념상 완전한 한 개의 도메인 모델을 표현하므로 객체의 영속성을 처리하는 리포지토리는 애그리거트 단위로 존재한다.
* 애그리거트는 개념적으로 하나이므로 리포지토리는 애그리거트 전체를 저장소에 영속화해야 한다.

## 3.4 ID를 이용한 애그리거트 참조
* 애그리거트에서 다른 애그리거트를 참조한다는 것은 다른 애그리거트의 루트를 참조한다는 것과 같다.

### 외부 애그리거트를 참조하는 것에 대해서..
```text
order.getOrderer().getMember().getId();
```
* Order라는 애그리거트에서 엔티티 그래프를 통해서 다른 애그리거트인 Member를 직접 접근하고 있다.
  * Order 애그리거트가 Member 애그리거트의 영역에 침범한 것이다.
* 위와 같은 코드는 다른 애그리거트와의 결합도가 발생하여 확장의 어려움을 야기할 수 있다.
* 이를 해결하기 위해서 애그리거트 루트의 식별자인 Id 값을 참조하도록 하는 것이다.
```java
public class Order {
    private Orderer orderer;
}

public class Orderer {
    private MemberId memberId;
    private String name;
}
```
```java
public class Member {
    private MemberId id;
    // ...
}
```
* 애그리거트가 다른 애그리거트를 직접 참조하지 않고 식별자를 통해서 참조하도록 하면 애그리거트 간의 물리적 연결을 제거할 수 있다.

```text
Member member = memberRepository.findById(order.getOrderer().getMemberId());
```
* 책에서는 Member 애그리거트를 식별자를 통해서 가져오도록 했지만 'order.getOrderer().getMemberId()' 코드가 좋은 코드인지는 잘 모르겠다.
* Order라는 엔티티를 캡슐화 해놓고 자신의 내부 정보를 응용 계층에 전부 드러내고 있기 때문이다.

```java
public class Order {
    private Orderer orderer;
    
    public Long getOrdererId() {
        return orderer.getMemberId().value;
    }
}
```
* 위와 같이 'order.getOrdererId()' 정도로 작성하는건 어떨까 싶은 생각이 든다.

### 애그리거트 저장소의 분산
* 시스템이 커지고 애그리거트 별로 다른 기술을 사용한다면 한 번의 쿼리로 관련 애그리거트를 조회할 수 없다.
* 이런 문제를 해결하기 위해 캐시를 활용하거나 조회 전용 저장소를 따로 구성하면 코드의 복잡성은 올라갈 수 있지만 시스템의 처리량을 높일 수 있다.
* 명령 모델과 조회 전용 모델을 분리하는 패턴으로 CQRS가 있다.
