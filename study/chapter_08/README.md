# Chapter 08. 애그리거트 트랜잭션 관리

## 애그리거트와 트랜잭션
* 트랜잭션마다 리포지터리는 새로운 애그리거트 객체를 생성하므로 개념적으로는 동일한 애그리거트지만 물리적으로는 서로 다른 애그리거트 객체이다.
* 이로인해 애그리거트의 일관성이 깨질 수 있다.
* 일관성이 깨지는 문제가 발생하지 않도록 하려면 다음 두 가지 중 하나의 방법을 사용해야 한다.
  * 한 스레드가 조회하고 상태를 변경하는 동안, 다른 스레드가 애그리거트를 수정하지 못하게 막는다.
  * 한 스레드가 조회한 이후에 다른 스레드가 정보를 변경하면, 먼저 조회한 스레드의 애그리거트를 다시 조회한 뒤 수정하도록 한다.
* 애그리거트에 대해 사용할 수 있는 대표적인 트랜잭션 처리 방식에는 선점(Pessimistic) 잠금과 비선점(Optimistic) 잠금이 있다.
  * Pessimistic Lock은 비관적 잠금, Optimistic Lock은 낙관적 잠금이라고 표현하기도 한다.

## Pessimistic Lock
* 비관적 잠금은 트랜잭션간 경합이 발생할 것이라는 가정을 가지고 Lock을 우선적으로 걸고 트랜잭션을 처리한다.
* 한 스레드가 락을 선점하고 있다면 다른 스레드는 접근을 위해 블로킹된다.
* 스레드간의 경합에서는 안전하지만 동시성 성능에 대해서 트레이드 오프가 발생한다.
* 교착 상태가 발생하지 않도록 주의해야 한다.
* DBMS에 따라 교착 상태에 빠진 커넥션을 처리하는 방식이 다르므로 사용하는 DBMS에 대해 어떤 방식으로 처리하는지 확인해야 한다.

## Optimistic Lock
* 낙관적 잠금은 트랜잭션간 경합이 발생하지 않을 것이라는 가정을 가지고 Lock을 우선적으로 걸지 않는다.
* 동시 접근으로 인해 발생하는 일관성 문제는 버저닝을 통해 해결할 수 있다.
* 애그리거트는 수정될 때마다 새로운 버전이 생긴다.
* 트랜잭션 당시에 조회했던 버전을 조건절에 넣음으로써 버전이 일치하는 경우에만 수정이 되도록 한다.
* 애그리거트 정보를 뷰로 보여줄 때는 버전 정보도 함께 사용자에 전달해야 하고, 서버로 다시 요청할 때도 버전 정보를 함께 전달해야한다.

### 강제 버전 증가
* 애그리거트 루트의 값이 바뀌지 않았더라도 애그리거트의 구성요소 중 일부 값이 바뀌면 논리적으로 그 애그리거트는 바뀐 것이므로 루트 애그리거트의 버전 값이 증가해야 한다.

## 오프라인 선점 잠금
* 단일 트랜잭션에서 동시 변경을 막는 선전 잠금 방식과 달리 오프라인 선점 잠금은 여러 트랜잭션에 걸쳐 동시 변경을 막는다.
* 한 트랜잭션이 락을 선점하고 있으면 다른 스레드는 
* 잠금을 해제하지 않는 경우에는 다른 트랜잭션에서 영원히 잠금을 가질 수 없으므로 적절한 시간의 잠금 유효시간을 가져야한다.
