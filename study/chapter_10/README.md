# Chapter 10. 이벤트

## 시스템 간 강결합 문제
* 시스템에는 내부 뿐만 아니라, 외부의 시스템을 이용하는 경우가 빈번하다.
* 외부 시스템을 이용하는 경우, 외부 시스템의 상태에 따라 도메인 기능 수행에 있어서 트랜잭션 처리에 대한 문제를 고민해야 한다.
  * 외부 시스템이 장애가 발생한 경우에 내부 도메인 기능을 수행하는 것을 멈추고 롤백해야하는가?
  * 일단 트랜잭션을 마저 수행하고, 나중에 후처리로 다시 시도해야할까?
  * 외부 시스템으로부터의 응답 시간이 길어지면 어떻게 해야할까?
* 외부 시스템과의 강결합은 외부 시스템의 성능이나 이슈에 대해 영향을 받게되는 문제가 발생한다.
* 외부 시스템과의 강결합은 서로 다른 도메인 로직이 섞이는 문제가 발생하고, 트랜잭션 처리 또한 복잡해진다.
* 이는 서로 다른 바운디드 컨텍스트간의 강결합 때문에 발생하는데, 이를 해결할 수 있는 방법으로 이벤트를 활용하는 것이다.

## 이벤트 개요
* 이벤트가 발생한다는 것은 상태가 변경됐다는 것을 의미한다.
* 도메인의 상태 변경을 이벤트로 표현할 수 있다.

### 이벤트 관련 구성요소
* 이벤트를 구현하기 위해서는 아래와 같은 구성요소를 구현해야 한다.
  * 이벤트
  * 이벤트 생성 주체
  * 이벤츠 디스패처 (Publisher)
  * 이벤트 핸들러 (Subscriber)
* 도메인 모델에서 이벤트 생성 주체는 엔티티, 밸류, 도메인 서비스와 같은 도메인 객체이다. 도메인 객체는 도메인 로직을 수행하면서 상태가 바뀌면 관련 이벤트를 발생시킨다.
* 이벤트 핸들러는 이벤트 생성 주체가 발생시킨 이벤트를 전달받아 원하는 기능을 실행한다.
* 이벤트 생성 주체와 이벤트 핸들러를 연결해 주는 것이 이벤트 디스패처다.
* 이벤트 생성 주체는 이벤트를 생성해서 디스패처에 이벤트를 전달하고, 디스패처는 해당 이벤트를 처리할 수 있는 핸들러에 전파한다.

### 이벤트의 구성
* 이벤트는 데이터를 담아야 하지만 그렇다고 이벤트 자체와 관련이 없는 데이터를 포함할 필요는 없다.

### 이벤트 용도
* 트리거
  * 도메인의 상태가 바뀔 때 다른 후처리가 필요하면 후처리를 위한 트리거로 사용할 수 있다.
* 데이터 동기화
  * 도메인의 상태가 변경되면 외부 서비스에 변경된 상태에 대한 정보를 전송하여 동기화시키도록 할 수 있다.

### 이벤트 장점
* 서로 다른 도메인 로직이 섞이는 것을 방지할 수 있다.
* 시스템 간의 루즈 커플링으로 인해 기능을 확장하기에 용이하다.

## 동기 이벤트 처리 문제
* 이벤트를 동기로 처리하게 되면 외부 서비스의 성능 저하가 내부 서비스의 성능 저하로 연결된다.
* 이벤트에서 익셉션이 발생하면 이벤트를 호출했던 트랜잭션 또한 롤백해야 하는지에 대해서 고민해볼 필요가 있다.
* 외부 시스템과의 연동을 동기로 처리할 때 발생하는 성능과 트랜잭션 범위 문제를 해소하는 방법은 이벤트를 비동기로 처리하거나 이벤트와 트랜잭션을 연계하는 것이다.

## 비동기 이벤트 처리
* 이벤트를 비동기로 처리하는 방법은 아래와 같은 방법으로 처리할 수 있다.
  * 로컬 핸들러를 비동기로 실행하기
  * 메시지 큐를 사용하기
  * 이벤트 저장소와 이벤트 포워더 사용하기
  * 이벤트 저장소와 이벤트 제공 API 사용하기

### 로컬 핸들러 비동기 실행
* 하나의 서비스 내에서 핸들러 자체를 비동기로 실행하는 방법이다.

### 메시징 시스템을 이용한 비동기 구현
* 카프카나 래빗MQ와 같은 메시징 시스템을 이용하여 구현한다.
* 이벤트를 발행하는 프로세스와 발행된 이벤트를 처리하는 프로세스가 분리되어 처리된다.
* 이벤트를 발생시키는 도메인과 메시지 큐에 이벤트를 저장하는 절차를 한 트랜잭션으로 묶을 수 있다.
  * 이와 같은 글로벌 트랜잭션은 메시지 큐에 안정적으로 이벤트를 전달할 수 있다는 장점이 있다.
  * 하지만 글로벌 트랜잭션으로 인해 전체 성능이 떨어지는 단점이 있다.

### 이벤트 저장소를 이용한 비동기 처리
* 이벤트를 일단 DB에 저장한 뒤에 별도의 프로그램을 이용해서 이벤트 핸들러에 전달하는 방버이다.
* 이벤트가 발생하면 핸들러는 스토리에 이벤트를 저장하고, 포워더는 주기적으로 이벤트 저장소에서 이벤트를 가져와 이벤트 핸들러를 실행시킨다.
* 포워더는 별도의 스레드를 이용하기 때문에 비동기적으로 실행된다.
* 이 방식은 도메인의 상태와 이벤트 저장소로 동일한 DB를 사용한다. 즉, 도메인의 상태 변화와 이벤트 저장이 로컬 트랜잭션으로 처리된다.
* 이벤트를 물리적 저장소에 보관하기 때문에 핸들러가 이벤트 처리를 실패할 경우 포워더는 다시 이벤트 저장소에서 이벤트를 읽어와 핸들러를 실행하면 된다.

### 이벤트 저장소와 이벤트 제공 API를 이용한 처리
* 이벤트를 외부에 제공하는 API를 사용하여 이벤트를 처리할 수 있다.
* API 방식과 포워더 방식의 차이점은 이벤트를 전달하는 방식이다.
* 포워더 방식은 포워더를 통해 이벤트를 외부에 전달한다면, API 방식은 외부 핸들러가 API 서버를 통해 이벤트 목록을 가져간다.
* 포워더 방식은 이벤트를 어디까지 처리했는지 추적하는 역할이 포워더에 있다면 API 방식에는 이벤트 목록을 요구하는 외부 핸들러가 자신이 어디까지 이벤트를 처리했는지 추적해야한다.

> 그냥 카프카나 래빗MQ와 같은 메시지 큐를 사용하자..

## 이벤트 적용 시 고려사항
* 이벤트가 손실될 가능성이 존재한다.
  * 메시지 큐와 같은 경우에 이벤트 손실에 대해 재시도 할 수 있도록 Dead-letter queue를 이용해 볼 수 있다.
* 이벤트는 발생 순서와 전달 순서가 다를 수 있다.
  * 이벤트 전달 순서에 따라 일관성이 깨질 수 있다면 사가 패턴을 이용하여 해결할 수 있다.
* 이벤트의 중복 실행
  * 메시지 큐를 사용할 경우, 해당 이벤트가 최초 한 번만 실행됨을 보장하지 못할 수 있다.
  * 멱등성을 보장하여 이벤트 메시지가 여러 번 수행되더라도 일관성이 깨지지 않도록 한다.
